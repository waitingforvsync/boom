length = &70
dest = &72
bitstream = &74
numsymbols = &76
count = &77
numbitvals = &80

dictionary = &900


.getbit
    \\ Gets one bit from the bitstream
    \\ On exit:
    \\   A preserved
    \\   X preserved
    \\   Y corrupted
    \\   C = bit
    LSR bitstream
    BNE samebyte

compressed_huffman_src = P%+1
    LDY &FFFF
    INC compressed_huffman_src
    BNE P%+5
    INC compressed_huffman_src+1
    STY bitstream
    ROR bitstream
.samebyte
    RTS


.get8bits
    LDX #7
.getbits
    \\ Gets a value composed of a specified number of bits from the bitstream
    \\ Note: bits must be stored reversed (most significant bit first)
    \\ On entry:
    \\   X = number of bits minus 1
    \\ On exit:
    \\   A = value lsb
    \\   X = &FF
    \\   Y corrupted
    \\   temp = value msb
    \\   C undefined
    LDA #0
    .getbitsloop
    JSR getbit
    ROL A
    DEX
    BPL getbitsloop
    RTS


.builddictionary
    \\ Given a table of code lengths indexed by symbol value,
    \\ generate a dictionary mapping huffman code to symbol value
    \\ On entry:
    \\   (dest)       = array of code lengths indexed by symbol value
    \\ On exit:
    \\   dictionary[] = symbol values indexed by huffman code
    \\   numbitvals[] = number of symbols with the indexed code length

    LDA #0
    STA dictionary_addr
	LDA #1              ; code length being searched for
.dicloop1
	LDX #0              ; tally of how many symbols have this code length
	LDY #0              ; symbol value
.dicloop2
	CMP (dest),Y
	BNE dicnext
	INX                 ; increment tally
dictionary_addr = P%+1
    STY dictionary      ; note: must be page aligned
	INC dictionary_addr
.dicnext
	INY
    CPY numsymbols
    BNE dicloop2        ; loop for all symbol values

	TAY
    TXA                 ; tally total
    STA numbitvals-1,Y  ; store tally total for this code length
	INY                 ; increment code length being searched
    TYA
	CMP #16
    BNE dicloop1        ; reloop for all code lengths until 16
	RTS


.gethuffmancode
    \\ Gets a huffman code from the bitstream and returns the corresponding symbol value
    \\ The dictionary and numbitvals table must have been built previously
    \\ On exit:
    \\   A = symbol value
    \\   X,Y corrupted
    \\   C = dictionary overflow
	LDA #0
	LDX #255
.gethuffmanloop
	INX
	JSR getbit
	ROL A
	SEC
	SBC numbitvals,X
	BCS gethuffmanloop
.gethuffmanloop2
	CLC
	ADC numbitvals,X
	DEX
	BPL gethuffmanloop2
	TAX
	LDA dictionary,X
	RTS



.decompress_huffman
    LDA #1:STA bitstream

    \\ Build huffman dictionary dictionary
    LDA #0:STA numsymbols
    .builddictloop
    LDX #2:JSR getbits
    LDY numsymbols:STA (dest),Y
    INY:CPY #16
    STY numsymbols
    BNE builddictloop

    JSR builddictionary

    \\ Expand 'proper' huffman dictionary
    LDA #0:STA count:STA count+1:STA numsymbols
    .builddict2loop
    JSR gethuffmancode
    LDY count:STA (dest),Y
    INC count
    BNE builddict2loop

    JSR builddictionary

    JSR get8bits:STA length
    JSR get8bits:STA length+1

    .decompress_loop
    JSR gethuffmancode
    LDY count:STA (dest),Y
    INY:BNE adjustmsbs
    INC count+1:INC dest+1
    .adjustmsbs
    STY count
    CPY length
    BNE decompress_loop
    LDA count+1
    CMP length+1
    BNE decompress_loop

    RTS