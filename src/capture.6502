


.capture_test
{
	LDY #1
	LDA #0:STA line_x0,Y
	LDA &FF:STA line_x1,Y
	LDA #5:STA line_y0,Y
	LDA colourtab0 + colour_bright_blue:STA line_colour0,Y
	LDA colourtab1 + colour_bright_blue:STA line_colour1,Y
	SEC:LDA line_x1,Y:SBC line_x0,Y:TAX
	SEC:LDA #22:SBC line_y0,Y
	STY savey
	JSR calc_gradient
	LDY savey
	STA line_dydxlo,Y
	TXA:STA line_dydxhi,Y

	INY
	LDA #0:STA line_x0,Y
	LDA &FF:STA line_x1,Y
	LDA #118:STA line_y0,Y
	LDA colourtab0 + colour_bright_blue:EOR colourtab0 + colour_dark_red:STA line_colour0,Y
	LDA colourtab1 + colour_bright_blue:EOR colourtab1 + colour_dark_red:STA line_colour1,Y
	SEC:LDA line_x1,Y:SBC line_x0,Y:TAX
	SEC:LDA line_y0,Y:SBC #69
	STY savey
	JSR calc_gradient
	LDY savey
	STA line_dydxlo,Y
	TXA:ORA #&80:STA line_dydxhi,Y

	INY
	LDA &FF:STA line_x0,Y
	LDA #128:STA line_x1,Y
	LDA #22:STA line_y0,Y
	LDA colourtab0 + colour_dark_blue:STA line_colour0,Y
	LDA colourtab1 + colour_dark_blue:STA line_colour1,Y
	SEC:LDA line_x1,Y:SBC line_x0,Y:TAX
	SEC:LDA line_y0,Y:SBC #11
	STY savey
	JSR calc_gradient
	LDY savey
	STA line_dydxlo,Y
	TXA:ORA #&80:STA line_dydxhi,Y

	INY
	LDA &FF:STA line_x0,Y
	LDA #128:STA line_x1,Y
	LDA #69:STA line_y0,Y
	LDA colourtab0 + colour_dark_blue:EOR colourtab0 + colour_dark_red:STA line_colour0,Y
	LDA colourtab1 + colour_dark_blue:EOR colourtab1 + colour_dark_red:STA line_colour1,Y
	SEC:LDA line_x1,Y:SBC line_x0,Y:TAX
	SEC:LDA #118:SBC line_y0,Y
	STY savey
	JSR calc_gradient
	LDY savey
	STA line_dydxlo,Y
	TXA:STA line_dydxhi,Y

	LDA #5:STA numlines
	RTS
}


.capture

	\\ set up initial lines
	
	; [0] is the lower line
	; [1] is the upper line
	LDA #0:STA line_x0+0:STA line_x0+1
	STA line_y0+1
	STA line_dydxlo+0:STA line_dydxhi+0
	STA line_dydxlo+1:STA line_dydxhi+1
	STA line_colour0+0:STA line_colour1+0
	STA numcachedsubzones
	LDA #128:STA line_y0+0
	STA line_x1+0:STA line_x1+1
	
	\\ cache the start subzone

	LDY playersubzone
	JSR initialise_subzone
	LDA #0:STA szc_lower_bounds+0
	LDA #1:STA szc_upper_bounds+0

	LDX playerzone
	.capture_sm_zone_ceiling_colours LDY &FFFF,X
	LDA colourtab0,Y:STA line_colour0+1
	LDA colourtab1,Y:STA line_colour1+1
	
	LDA #2:STA numlines
		
	\\ Get start index for iteration round the initial subzone
	
	; Get the angle of the second column of the screen
	; We are looking for an edge which starts at a lesser angle and finishes on a greater or equal one
	SEC
	LDA playerangle:SBC #fov_offset-1:STA tempangle
	LDA playerangle+1:SBC #0:AND #3:STA tempangle+1

	; Now go round the initial contour looking for such a point
	; We start at startcontindex (the index we obtained last frame), assuming that not much will have changed.	
	LDY startcontindex:;JSR get_relative_vertex_pos

	; copy the dx,dy return values to a "safe" place because getworldangle corrupts them
	STA dy0+1:LDA dy:STA dy0
	LDA dx+1:STA dx0+1:LDA dx:STA dx0

	; compare the world angle to the second column angle
	; while we're at it, store the difference in X for later
	JSR getworldangle
	SEC:SBC tempangle:TAX:LDA angle+1:SBC tempangle+1:AND #2
	BEQ lookbackwards		; this indicates that we need to search backwards for the new edge

	; OK, we are now iterating clockwise round the contour, looking to see if this edge
	; crosses the boundary angle
	LDY startcontindex:DEY:BPL P%+4:LDY cont_num_verts:STY startcontindex
	;JSR get_relative_vertex_pos
	STA dy1+1:LDA dy:STA dy1
	LDA dx+1:STA dx1+1:LDA dx:STA dx1
	JSR getworldangle

	.lookbackwards

	; If we came here, we are now iterating anticlockwise round the contour, looking for an
	; edge which crosses the boundary angle.
	; First we have to redesignate dx0,dy0 as dx1,dy1 as this is now potentially an endpoint.
	LDA dx0:STA dx1:LDA dx0+1:STA dx0+1
	LDA dy0:STA dy1:LDA dy0+1:STA dy1+1


	RTS
