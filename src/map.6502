
; Inputs:
;   (read) = base of map

.initialise_map
{
	LDY #0
	STY playerxfrac:STY playeryfrac

	\\ Initialize pointers to all the map tables, relative to the map base
	\\ We always access inline through an abs,X or abs,Y instruction.
	\\ This is both faster than an (ind),Y access and also more flexible.
	\\ So we need to provide a table of all the operand addresses for each map table access
	\\ and self-modify them here.
	LDX #0
	.initmapoffsets
	CLC
	LDA (read),Y:ADC read:STA temp:INY
	LDA (read),Y:ADC read+1:STA temp+1:INY
	.addrcopyloop
	LDA inlineaddrs,X:STA addrsm+1:INX
	LDA inlineaddrs,X:PHA:AND #&7F:STA addrsm+2:INX
	TXA:PHA
	LDX #1
	.copy2bytes
	LDA temp,X:.addrsm STA &FFFF,X
	DEX
	BPL copy2bytes
	PLA:TAX
	PLA:BPL addrcopyloop
	CPY #map_offsets_size
	BNE initmapoffsets

	\\ Initialize player start position (multiply start positions by 32)
	LDX #1
	.initplayerstart
	LDA (read),Y:STA playeryhi,X:LDA #0
	LSR playeryhi,X:ROR A:LSR playeryhi,X:ROR A:LSR playeryhi,X:ROR A:STA playerylo,X
	INY
	DEX:BPL initplayerstart
		
	\\ Initialize player start angle (multiply start angle by 4)
	LDA (read),Y:STA playerangle:LDA #0
	ASL playerangle:ROL A:ASL playerangle:ROL A:STA playerangle+1
	INY
	
	\\ Initialize player subzone
	LDA (read),Y:STA playersubzone
	INY
		
	\\ Initialize subzone cache indices to invalid
	LDX #0:TXA		; 0 is an invalid subzone index
	.initsubzonecache
	STA sz_cache_indices,X
	INX
	BNE initsubzonecache
	
	\\ Initialize player z from subzone floor height
	LDY playersubzone
	.init_map_sm_subzone_zone_index LDX &FFFF,Y
	STX playerzone
	.init_map_sm_zone_floor_heights LDA &FFFF,X
	SEC:SBC #player_height
	STA playerz
	
	RTS

.inlineaddrs
	\\ List of all the operand addresses which need to be modified.
	\\ Final one for each table has bit 15 set.
	\\ vertex_xlo
	EQUW tempbuffer+&8000
	\\ vertex_xhi
	EQUW tempbuffer+&8000
	\\ vertex_ylo
	EQUW tempbuffer+&8000
	\\ vertex_yhi
	EQUW tempbuffer+&8000
	\\ contour_vertex_lists
	EQUW cont_vertices_base+&8000
	\\ contour_subzone_lists
	EQUW cont_subzones_base+&8000
	\\ contour_edge_colour_lists
	EQUW cont_edge_colours_base+&8000
	\\ subzone_start_list_index
	EQUW (init_subzone_sm_subzone_list_index+1)+&8000
	\\ subzone_num_verts
	EQUW (init_subzone_sm_subzone_num_verts+1)+&8000
	\\ subzone_zone_index
	EQUW (init_map_sm_subzone_zone_index+1)+&8000
	\\ zone_floor_heights
	EQUW (init_map_sm_zone_floor_heights+1)+&8000
	\\ zone_ceiling_heights
	EQUW (capture_sm_zone_ceiling_colours+1)+&8000
	\\ zone_floor_colours
	EQUW tempbuffer+&8000
	\\ zone_ceiling_colours
	EQUW tempbuffer+&8000
}


; Inputs:
;    Y = subzone to initialize
;
; Outputs:
;    X = subzone cache index
;    C = set if it was newly cached (and needs initializing)

.initialise_subzone

	; Get a pointer to the contour vertex list for this subzone
	CLC
	.init_subzone_sm_subzone_list_index LDX &FFFF,Y
	TXA:ADC cont_vertices_base:STA cont_vertices
	LDA cont_vertices_base+1:ADC #0:STA cont_vertices+1
	
	; Get a pointer to the contour subzone list for this subzone (C clear)
	TXA:ADC cont_subzones_base:STA cont_subzones
	LDA cont_subzones_base+1:ADC #0:STA cont_subzones+1

	; Get a pointer to the contour edge list for this subzone (C clear)
	TXA:ADC cont_edge_colours_base:STA cont_edge_colours
	LDA cont_edge_colours_base+1:ADC #0:STA cont_edge_colours+1
	
	; Cache the vertex count for this subzone
	.init_subzone_sm_subzone_num_verts LDA &FFFF,Y
	STA cont_num_verts
	
	; Allocate a new subzone cache entry if necessary
	LDX sz_cache_indices,Y:BNE initialised_subzone		; with C clear
	
	LDA numcachedsubzones:STA sz_cache_indices,Y:TAX
	INC numcachedsubzones
	TYA:STA szc_subzone_indices,X
	SEC										; C set indicates a newly cached subzone
	
	.initialised_subzone
	RTS



.clear_world_angle_cache
{
	LDX cont_num_verts	; num verts in the current contour, minus one
	LDA #&FF
	.loop
	STA world_angle_cache_hi,X
	DEX
	BPL loop
	RTS
}


.clear_subzone_cache
{
	LDX numcachedsubzones:DEX	; will always be at least 1
	LDA #0						; invalid subzone index
	.loop
	LDY szc_subzone_indices,X
	STA sz_cache_indices,Y
	DEX
	BPL loop
	RTS
}


\.get_relative_vertex_pos
\
\	; on entry:
\	; Y = contour point index
\	; on exit:
\	; dx,dy = relative position of point
\
\	LDA (cont_vertices),Y:TAX
\
\	.vert_xs_inline LDA &FFFF,X:STA dx+1
\	LDA #0:LSR dx+1:ROR A:LSR dx+1:ROR A:LSR dx+1:ROR A
\	SEC:SBC playerx+1:STA dx
\	LDA dx+1:SBC playerx+2:STA dx+1
\
\	.vert_ys_inline LDA &FFFF,X:STA dy+1
\	LDA #0:LSR dy+1:ROR A:LSR dy+1:ROR A:LSR dy+1:ROR A
\	SEC:SBC playery+1:STA dy
\	LDA dy+1:SBC playery+2:STA dy+1
\
\	RTS
