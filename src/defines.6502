screen_width = 128				; screen width in pixels
screen_height = 128				; screen height in pixels

player_radius = 15
player_height = 41

screen_hsync_pos = 45
screen_vsync_pos = 31
screen_vsync_width = 2
hud_rows = 3

max_lines = 128
max_subzones = 64

sz_cache_indices = &300


MACRO CHECKTABLE base
	IF HI(P%)<>HI(base)
		ERROR "Table crosses page boundary"
	ENDIF
ENDMACRO


ORG &400
.multablo		SKIP &200				; &400
.multabhi		SKIP &200				; &600
.screenaddrhud	SKIP &100 * hud_rows	; &800
.multabneglo	SKIP &200				; &B00

; for now skip over pages &D-&10
ORG &1100
.multabneghi	SKIP &200				; &1100
.reciptablo		SKIP &100				; &1300
.reciptabhi		SKIP &100				; &1400
.sintab			SKIP &80				; &1500

.line_x0		SKIP max_lines			; &1580
.line_x1		SKIP max_lines			; &1600
.line_y0		SKIP max_lines			; &1680
.line_dydxlo	SKIP max_lines			; &1700
.line_dydxhi	SKIP max_lines			; &1780

.screenaddr1	SKIP &1000				; &1800
.tempbuffer		SKIP &100				; &2800		; line rendering can corrupt the row below the screen, use it as scratch space

szc_subzone_indices = tempbuffer + &00
szc_vert_indices = tempbuffer + &40
szc_upper_bounds = tempbuffer + &80
szc_lower_bounds = tempbuffer + &C0

.line_colour0	SKIP max_lines			; &2900
.line_colour1	SKIP max_lines			; &2980
.line_next		SKIP max_lines			; &2A00

\\ Eventually we will put more subzone cache tables here


ALIGN &100
.codestart								; &2B00


screenaddr2 = &7000

\\ Make sure the screen buffers are &800-aligned, so their (addr DIV 8) fits into R12 alone
IF (screenaddr1 AND &7FF) OR (screenaddr2 AND &7FF) OR (screenaddrhud AND &7FF)
	ERROR "Screen buffer is misaligned"
ENDIF


\\ Size of these generated routines
screenfillsize = &18B
screenclearsize = &34

screenclear2 = screenaddr2 - screenclearsize
screenclear1 = screenclear2 - screenclearsize
screenfill2 = screenclear1 - screenfillsize
screenfill1 = screenfill2 - screenfillsize



ORG 0

\\ variables which need to be initialized to something
\\ remember to update entry.6502 as more are added
.zpinit_start
.mullo_ptr			SKIP 2
.mulneglo_ptr		SKIP 2
.mulhi_ptr			SKIP 2
.mulneghi_ptr		SKIP 2
.scrnbase			SKIP 1
.dispscrnhi			SKIP 2

\\ put zero-initialized ones at the end in case we want to do a special path to initialize them
.scrnswapflag		SKIP 1
.numbars			SKIP 1
.numlines			SKIP 1
.numcachedsubzones	SKIP 1
.startcontindex		SKIP 1
.zpinit_end


; distancealongray, clippeddistance, getworldangle, calcworldnormalquadrant, drawline
.dx					SKIP 2
.dy					SKIP 2
.dx0				SKIP 2
.dy0				SKIP 2
.dx1				SKIP 2
.dy1				SKIP 2

; getworldangle
.angle				SKIP 2
.angle0				SKIP 2
.angle1				SKIP 2

; distancealongray
.xc					SKIP 2
.ys					SKIP 2

; normalise_z, applyperspective, clippeddistance, distancealongray
.distance			SKIP 2

; normalise_z, applyperspective
.zshift				SKIP 1
.result				SKIP 2

; generic
.read				SKIP 2
.write				SKIP 2
.addr				SKIP 2
.temp				SKIP 2
.savex				SKIP 1
.savey				SKIP 1
.count				SKIP 1
.tempangle			SKIP 2
.anglediff			SKIP 2
.multemp1			SKIP 1
.multemp2			SKIP 1

; game
.playeryfrac		SKIP 1
.playerxfrac		SKIP 1
.playerylo			SKIP 1
.playerxlo			SKIP 1
.playeryhi			SKIP 1
.playerxhi			SKIP 1

.playerz			SKIP 2
.playerangle		SKIP 2
.playersubzone		SKIP 1
.playerzone			SKIP 1

; clippeddistance
.clipangle			SKIP 2
.normalangle		SKIP 2

; timerbars
.barpos				SKIP 8
.oldbarend			SKIP 1

; drawline
.x0					SKIP 1
.x1					SKIP 1
.y0					SKIP 1
.y1					SKIP 1
.acc				SKIP 1
.state				SKIP 1
.dydxlo				SKIP 1
.dydxhi				SKIP 1

; Contour data base addrs
.cont_vertices_base		SKIP 2
.cont_subzones_base		SKIP 2
.cont_edge_colours_base	SKIP 2

; Current contour data
.cont_vertices			SKIP 2
.cont_subzones			SKIP 2
.cont_edge_colours		SKIP 2
.cont_num_verts			SKIP 1

.start

SKIPTO &78
.linecolours		SKIP 8

SKIPTO &FC
SKIP 1



GUARD screenfill1
